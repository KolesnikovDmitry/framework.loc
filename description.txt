Фремворк MVC
Урок 1
Структура
1. app - структура приложения, с которой будет работать пользователь, в ней создадим 3 подпапки
    controllers
    models
    views
2. public - точка входа(frontcontroller), здесь же будут находится картинки, стили, шрифты, скрипты и т.д.
    css 
    images
    js
3.vendor - ядро фреймворка и библиотеки
    core
    libs
Все запросы должны перенаправляться на папку public 
Создадим в папке public index.php - это и будет наша точка входа
Напишем "echo __FILE__;" - посмотреть путь который у нас. 
Запросы должны быть перенаправлены на index.php. Для этого мы создадим два файла .htaccess

Первый файл мы создаем в корне , запишем в него
    AddDefaultCharset utf-8
    RewriteEngine On - модуль перенаправления
    RewriteRule ^(.*)$  /public/$1 -правило перенаправления, которое все запросы отправит в папку public.
    И все, что мы запомнили находится в переменной $1, перенаправляется в папку public
Второй файл .htaccess мы создаем в папке public , запишем в него два условия:
    RewriteCond %{REQUEST_FILENAME} !-f   условие перенаправления.
    Если это не файл, и это не папка, тогда мы выполним следующее условие переадресации
    RewriteRule (.*) index.php?$1 [L,QSA] - запомним все, что будет находится в строке запроса и отправим на index.php
    и Get- параметром добавим $1, также добавим флаг L, QSA(позволяет добавлять параметры к уже имеющеся в строке запроса url)

Создаем класс Router . Создадим временно публичный метод конструктора, чтобы убедиться, что он работает. Напишем в 
него echo "hello world"
В index.php обратимся к массиву $query = $_SERVER['QUERY_STRING'];
Нам нужно подключить класс Router - require_once "../vendor/core/Router.php";

Создадим обьект класса $router = new Router;
Создадим в классе Router два свойства: Все свойства и методы данного класса будут статичными.

    /*
        Массив, содержащий все маршруты
        @var $array
    */
    protected static $routes = [];
    
    /*
        Текущий маршрут
        $var $array
    */
    protected static $route = [];

    /*

Создадим в классе Router статичный метод add, который будет принимать два параметра, 
один будет принимать регулярное выражение $regexp ,второй - $route

public static function add($regexp, $route = []) {
        self::$routes[$regexp] = $route;
    }
В качестве ключа таблицы маршрутов, пойдет регулярное выражение, а значение текущий маршрут

Создадим два метода для тестирования, чтобы посмотреть ,что там находится

    public static function getRoutes() {
            return self::$routes;
        }

        public static function getRoute() {
            return self::route;
        }
    }
Уберем создание объекта router в index.php и создадим первое правило
Router::add('posts/add', ['controller'=>'posts', 'action'=>'add']);

Создадим функцию function.php для дебага в папке vendor, подпапки libs и родключим его в index.php

    function debug($arr) {
        echo '<pre>' . print_r($arr, true) . '</pre>';
    }

Для примера добавим еще несколько вариантов, например:
Router::add('posts/', ['controller' => 'Posts', 'action'=>'index']);
Router::add('', ['controller' => 'Main', 'action'=>'index']);

Для сравнение строки url с ключом в маршруте создадим статичный метод, в качестве параметра будет приниматься запрос 
url(переменная query). Перебираем в цикле наши свойства routes(таблицу маршрутов) и получаем 
из нее отдельно регулярное выражение($pattern) и отдельно маршрут, который соответствует этому регулярному выражению
Делаем простую проверку сравнения: Проверяем , если у нас переменная $url == $pattern, заполняем наше свойство $route.
И вернем работу нашей функции, возращая true. Если совпадение найдено не было,запрошен не 
существующий адрес, вернем false
   public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if ($url == $pattern) {
                self::$route = $route;
                return true;
            } 
        }
        return false;
    }
Сделаем проверку на совпадение маршрутов
    if(Router::matchRoute($query)){
        debug(Router::getRoute());
    } else {
        echo '404';
    }
Решим проблему концевого слэша и допишем функцию rtrim, не забыв при этом убрать в маршруте posts/, слеш
$query = rtrim($_SERVER['QUERY_STRING'], '/');


Урок 2
Класс Router 
Сделаем правило в index.php, которое провалидирует пустую строку
    Router::add('^$',['controller' => 'Main', 'action'=>'index']); -где в регулярном выражении написаны символы начала 
    и конца строки, что означает пустую строку.
Второе правило должно валидировать все остальные url-адреса, где первый сегмент это контроллер, а второй экшен
    Router::add('([a-z-]+)/([a-z-]+)'); - где в регулярном выражении разрешаем
    вводим латиницу , знак тире и один или больше символов, и также для экшена
    Нужно эти правила запомнить, потому что мы их мы собираемся хранить в route
Закомментирум пока эти правила:
//Router::add('posts/add', ['controller' => 'Posts', 'action'=>'add']);
//Router::add('posts', ['controller' => 'Posts', 'action'=>'index']);
//Router::add('', ['controller' => 'Main', 'action'=>'index']);

Пропишем в Router:
Используем в сравнении функцию preg_match. Первым параметром идет паттерн. Вторым url-адрес. 
Третьий для запоминания $matches. Проверим, что же у нас попадает в $matches - debug($matches);

Сделаем именованные ключи в регулярном выражении, и сделаем необязательный слеш и action 
И если action у нас нет, тогда мы сделаем в качестве такового index 
   Router::add('^(?P<controller>[a-z-]+)/?(?P<action>[a-z-]+)?$');

Опишем в Router метод dispatch, на вход принимает url. И здесь этот метод вызывает matchRoute
Если метод matchRoute возвращает true, зачит адрес найден. В противном случае используем 
http_response_code(404), и подключим страницу 404.html
    public static function dispatch($url) {
           if (self::matchRoute($url)) {
               echo 'ok';
           } else {
               http_response_code(404);
               include '404.html';
           }
       }
Создадим в папке public 404.html
    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <title>404 Not found</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <h1 style="text-align: center;">404 Страница не найдена....</h1>
    </body>
    </html>
В index.php вызовем метод dispatch - Router::dispatch($query);
В пустой массив root метода matchRoute необходимо положить контроллер и action. 
Мы пройдемся по нашему массиву matches и возьмем значения только тех ключей, которые являются строковыми.
Если у нас в ключ попадается строковое значение, тогда нам такая строка подходит.
    public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if (preg_match("#$pattern#i", $url, $matches)) {
                debug($matches);
                foreach($matches as $key => $value) {
                    if (is_string($key)) {
                        $route[$key] = $value;
                    }
                }
                self::$route = $route;
                debug($route);
                return true;
            } 
        }
        return false;
    }
Однако, если в адресной строке опустить action, то его нет в выводе. И если action нет, то по умолчанию
он должен быть index
      public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if (preg_match("#$pattern#i", $url, $matches)) {
                foreach($matches as $key => $value) {
                    if (is_string($key)) {
                        $route[$key] = $value;
                    }
                }
                if (!isset($route['action'])) {
                    $route['action'] = 'index';
                }
                self::$route = $route;
                debug(self::$route);
                return true;
            } 
        }
        return false;
    }

Теперь переходим к методу dispach. У нас в этом методе доступен self::route. И отсюда возьмем контроллер
    $controller = self::$route['controller'];
Далее проверяем,если у нас есть такой класс в $controller, тогда мы его должны подключить.
В противном случае выведем сообщение, что контроллер не найден.
      public static function dispatch($url) {
        if (self::matchRoute($url)) {
            $controller = self::$route['controller'];
            if(class_exists($controller)){
                echo 'ok';
            } else {
                echo "Контроллер <b>$controller</b> не найден";
            }
        } else {
            http_response_code(404);
            include '404.html';
        } 
    }
Соответственно, создадим свой первый контроллер в папке app/controllers - Posts.php 
И еще Main.php. И временно подключим их в index.php
    require_once '../app/controllers/Posts.php';
    require_once '../app/controllers/Main.php';
Создадим еще класс PostsNew . И он должен быть найден при обращении в адресной строке posts-new
Сделаем в Router метод upperCamelCase. На вход будет пинимать имя класса $name
Распечатаем его:
    protected static function upperCamelCase($name) {
        debug($name);
    }
   И вставим вывод в метод dispatch - self::upperCamelCase($controller);
Уберем тире с имени контроллера - $name = str_replace('-', ' ',$name);
Сделаем заглавными первые буквы двух слов  - $name = ucwords($name);
Заменим пробел, чтобы соединить два слова - $name = str_replace(' ', '', $name);
Теперь сократим код в одну строку  - $name = str_replace(' ', '', ucwords(str_replace('-', ' ',$name)));

И вернем результат:
protected static function upperCamelCase($name) {
    return $name = str_replace(' ', '', ucwords(str_replace('-', ' ',$name)));
}

В Routere в методе dispatch исправим 
    $controller = self::$route['controller'] на 
    $controller = self::upperCamelCase(self::$route['controller']);
Создадим в папке app/controllers контроллер PostsNew
В методе dispatch создадим обьект данного класса - $cObj = new $controller;
Чтобы убедиться, что все работает создадим временно в PostsNew конструктор
    class PostsNew {

        public function __construct() {
            echo __METHOD__;
            } 
        }
    }
Обьект контроллера, мы успешно создали,теперь необходимо вызвать метод данного контроллера. 
Поступим, так же, как и с контроллером. В переменную action получим из self::route, необходимое нам 
значение. И проверим, если у нас существует, такой метод $action у класса $cObj, то выведем его 
$cObj->$action(); 
Иначе напишем в Routre метода dispach: 
    if(method_exists($cObj, $action )) {
        $cObj->$action();
    } else {
        echo "Метод <b>$controller::$action</b> не найден";
    }
Давайте в PostsNew создадим еще пару методов
     public function test()
    {
      echo __METHOD__;
    }
    
    public function testPage()
    {
      echo __METHOD__;
    }
Чтобы, вызвать testPage, надо нам убрать дефис и за ним следующую букву сделать заглавной.
Создадим еще один метод lowerCamelCase. Первую букву будет делать маленькой все остальные с большой.
    protected static function lowerCamelCase($name) {
        return lcfirst(self::upperCamelCase($name));
    }
В dispatch пропишем - $action = self::lowerCamelCase(self::$route['action']);
В PostsNew создадим еще метод: before, но нужно сделать, чтобы пользователь не мог его вызвать.
К каждому методу, который пользователь сможет вызывать, добавим постфикс Action 
А в Routere метода dispatch сконкатеннируем . "Action";
$action = self::lowerCamelCase(self::$route['action']) . "Action";

Сделаем константы:
define('WWW', __DIR__ ); - будет указывать на текущую папку public C:\OSPanel\domains\framework.loc\public
define('CORE', dirname(__DIR__). 'vendor/core'); - ядро сайта. С помощью функции dirname, поднимемся в папку выше.
Все константы будут заканчиваться без концевого слеша. C:\OSPanel\domains\framework.locvendor/core
define('ROOTE', dirname(__DIR__)); - корень сайта. C:\OSPanel\domains\framework.loc
define('APP', dirname(__DIR__) . '/app'); - C:\OSPanel\domains\framework.loc/app


Далее, сделаем функцию автозагрузки
spl_autoload_register(function($class){
    $file = APP . "/controllers/$class.php";
});
И проверим, если у нас есть такой файл, то мы его подключаем

В index.php пропишем еще маршрут 
Router::add('^pages/(?P<action>[a-z-]+)?$',['controller' => 'Posts']);




Урок 3. Автозагрузка. Контроллер фреймворка. Пространство имен.
Закомментируем класс Router. И посмотрим, что же у нас ищется в автозагрузчике
spl_autoload_register(function($class){
    debug($class);
    $file = APP . "/controllers/$class.php";
    if(is_file($file)){
        require_once $file;
    }
});
В Routere запишем - namespace vendor\core;
В index.php пропишем use vendor\core\Router;
Нам остается только в функции автозагрузки заменить обратные слеши на прямые и доканкатенировать
.php(т.е. дописать расширение) 
    spl_autoload_register(function($class){
        $file = ROOTE . '/' . str_replace('\\', '/', $class) . ".php";
        if(is_file($file)){
            require_once $file;
        }
    });
 
Включим контроль ошибок в index.php 
error_reporting(-1);

Допишем пространство имен в метод dispatche - $controller = 'app\controllers\\' . self::upperCamelCase(self::$route['controller']);
И пропишем пространство имен в контроллерах

namespace app\controllers;

Нам надо подключить шаблон(повторяющуся часть каждой страницы(head, body, стили, скриптов)) 
и вид(некая изменяющаяся часть каждого сайта(контент
Под каждый вид в папке views создадим папку по имени контроллера
Создадим папку Posts и PostsNew в views. Виды будут называться по имени action. То есть в 
папке views/Posts создадим два файла index.php и test.php
В index.php напишем <h1>INDEX</h1>
В test.php напишем <h1>TEST</h1>

Немного исправим методы dispatch и matchRoute, потому как контроллер выходит с маленькой буквы.
     public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if (preg_match("#$pattern#i", $url, $matches)) {
                foreach($matches as $key => $value) {
                    if (is_string($key)) {
                        $route[$key] = $value;
                    }
                }
                if (!isset($route['action'])) {
                    $route['action'] = 'index';
                }
                $route['controller'] = self::upperCamelCase($route['controller']); 
                self::$route = $route;
                return true;
            } 
        }
        return false;
    }


    public static function dispatch($url) {
        if (self::matchRoute($url)) {
            $controller = 'app\controllers\\' . self::$route['controller'];
            debug(self::$route);
            if(class_exists($controller)){
                $cObj = new $controller;
                $action = self::lowerCamelCase(self::$route['action']) . "Action";
                if(method_exists($cObj, $action )) {
                    $cObj->$action();
                } else {
                    echo "Метод <b>$controller::$action</b> не найден";
                }
            } else {
                echo "Контроллер <b>$controller</b> не найден";
            }
        } else {
            http_response_code(404);
            include '404.html';
        } 
    }
У нас теперь в маршруте, содержится вся информация, для подключения нужного вида. И теперь нужно
передать информацию в наш контроллер. Нужно в обьект класса $cObj передать self::$route
$cObj = new $controller(self::$route);
Соответственно, нам понадобится некое свойство $route = [];
Создадим, также публичный метод __construct, и будет выводить то, что приходит в наш конструктор параметром
при создании обьекта.
    public function __construct($route) {
            $this->route = $route;
    }
И теперь, у нас в debug($this->$route) содержится вся необходимая информация
И поэтому нам необходим некий базовый класс контроллера, который будет находиться в ядре core
Создадим папку в core / base и ней создадим абстрактный класс Controller и весь конструктор  с Pouter.php
перенесем в класс Controller
    public $route = [];
    
    public function __construct($route) {
        $this->route = $route;
    }
И нам остается только наследоваться от базового класса Controller
    namespace app\controllers;
    use vendor\core\base\Controller;

    class Posts extends Controller{

        public function indexAction() {
            echo __METHOD__;
        }

        public function testAction() {
            debug($this->route);
            echo __METHOD__;
        }
    }
Сделаем у классов контроллера тоже самое. Сделаем временно подключение вида
    abstract class Controller {
        public $route = [];
        public $view;

        public function __construct($route) {
            $this->route = $route;
            $this->view = $route['action'];
            include APP . "/views/{$route['controller']}/{$this->view}.php";
        }
    }
Напишем в Page:
    namespace app\controllers;
    use vendor\core\base\Controller;

    class Page extends Controller{

        public function viewAction() {
            debug($this->route);
            echo __METHOD__;
        }
    }
Сейчас у нас фактически один action отвечает за одну страницу. Это не всегда удобно
Добавим и изменим правила 
Router::add('^page/(?P<action>[a-z-]+)/(?P<alias>[a-z-]+)$',['controller' => 'Page']);
Уберем средний сегмент view. Напишем еще правило, в котором action уже убираем и оставляем только
alias, но action при этом должен быть именно view
Router::add('^page/(?P<alias>[a-z-]+)$',['controller' => 'Page', 'action' => 'view']);
Далее нам нужно разделить явные get-параметры от неявных и отрезать их.
Введем в адресную строку - http://framework.loc/page/view/about?page=1&val=2&val=3
И в index.php после подключения функций напишем debug($_GET);, где получим вывод
Array
(
    [page/view/about] => неявные get- параметры
    [page] => 1 - явные get-параметры
    [val] => 3
)
Создадим в Router метод removeQueryString, который будет обрезать возможные get-параметры
На вход он принимает url- адрес. Распечатаем его 
  protected static function removeQueryString($url) {
        debug($url);
        return $url;
    }
В методе dispatch распечатаем его - $url = self::removeQueryString($url);
Найдем строку по разделителю:
  protected static function removeQueryString($url) {
        if($url) {
            $params = explode('&', $url, 2);
            if(false === strpos($params[0], ))
        }
        //debug($url);
        return $url;
    }

Во всем случаях по-возможности мы должны взять только неявные get-параметры
 protected static function removeQueryString($url) {
        if($url) {
            $params = explode('&', $url, 2);
            if (false === strpos($params[0], '=')) {
                return rtrim($params[0], '/');
            } else {
                return '';  
            }
        }
    }

Выведем в методе dispatch - var_dump($url); Для версии php 8 и выше нужно в matchRoute привести к строковой
функции strval($url), чтобы пустая строка не приводилась к null 




Урок 4. Виды и шаблоны
Создадим базовый класс вида vendor/core/base/view.php
Нам понадобится три свойства - route(чтобы взять из него контроллер и значение action)
    class View {

        /**
         * текущий маршрут и параметры(controller, action, params)
         * @var array
         */
        public $route = [];

        /**
         * текущий вид
         * @var string
         */
        public $view;

        /**
         * текущий шаблон 
         * @var string
         */
        public $layout;
    }
Понадобится метод конструктора. Когда мы будет создавать обьект класса view, то будем заполнять все эти свойства,
текущими значениями вида и шаблона.
Заведем в index.php константу для нашего шаблона - define('LAYOUT', 'default');//default template
    public function __construct($route, $layout = '', $view = '' ) {
            $this->route = $route;
            $this->layout = $layout ?: LAYOUT; - если у нас layout был передан, то используем его, иначе используем константу LAYOUT 
            $this->view = $view;
        }

И понадобится метод render - мы его будем вызывать автоматом и в нем будем подключать вид,
шаблон и определять переменные вида и шаблона, которые,пользователь передает из action контроллера
    public function render() {
        $file_view = APP . "/views/{$this->route['controller']}/{$this->view}.php";
        if (is_file($file_view)) {
            require_once $file_view;
        } else {
            echo "<p>Не найден вид<b>$file_view</b></p>";
        }
    }
Нам необходимо в контроллере создать обьект вида и вызвать его метод render. Допишем 
    public function __construct($route) {
        $this->route = $route;
        $this->view = $route['action'];
    }
    
     public function getView() {
        $vObj = new View($this->route, $this->layout, $this->view);
        $vObj->render();
    }
Подключим в dispatch -  $cObj->getView();

Создадим некий общий класс в app/controllers - App.php отнаследуемся от базового контроллера
Controller
    namespace app\controllers;

    use vendor\core\base\Controller;
    class App extends Controller{
        //put your code here
    }
Теперь каждый класс будем наследовать от класса App

Нам надо чтобы вид не подключался раньше шаблона, и тем более чтобы он не выводился, до тех пор пока мы этого не захотим.
Подключим возможности буферизации, которая фактически, все что идет после нее буферизирует, т.е.
складывает в буфер обмена, не выводя при этом на экран.
Заведем переменную и положим туда все, что находится в буфере обмена - $content = ob_get_clean();
которая очищает буфер обмена и складывает в $content
Теперь мы можем подключать наш шаблон, а внутри шаблона использовать переменную $content с видом 
в нужном месте нашего шаблона.
Шаблон подключаем, либо тот, который укажет пользователь на уровне контроллера и экшена или
если он не указал, тогда мы используем дефолтный шаблон, который лежит у нас в константе LAYOUT
И проверим, если у нас существует такой файл layuout, тогда мы его подключаем
Выводится сообщение не найден шаблон, давайте его найдем.
В папке views создадим папку layouts и в ней default.php
В шаблон подключим bootstrap, скачаем его с офф.сайта. Переименуем в bootstrap. И закинем в папку 
public
В default.php вставим шаблон bootstrap
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>DEFAULT</title>

        <link href="/public/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
          <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->
      </head>
      <body>
        <h1>Hello, world!</h1>
        <?= $content?> - подключим переменную

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <script src="/public/bootstrap/js/bootstrap.min.js"></script>
      </body>
    </html>

Все теперь подключается по умолчанию, шаблон и вид.
Сделаем проверку во view - 
 public function __construct($route, $layout = '', $view = '' ) {
        $this->route = $route;
        $this->layout = $layout ?: LAYOUT;
        $this->view = $view;
        var_dump($this->layout); 
        var_dump($this->view); 
    }
Посмотрим, что там находится. Попробуем передать другой шаблон. Для этого идем в main 
    class Main extends App{
        public function indexAction() {
            $this->layout = 'main';
            $this->view = 'test';
         }
}
Шаблон main мы успешно переопределили. Это мы сделали на уровне action. Теперь сделаем
на уровне всего класса.
    class Main extends App{
        public $layout = 'main';
        public function indexAction() {
    //       $this->layout = 'main';
    //       $this->view = 'test';
        }
    }
Чтобы, убедиться, что все работает. создадим вид test.php во views/Main
В views/layouts создадим шаблон main.php
С default возьмем всю разметку вставим ее в main
title перепишем в main -  <title>MAIN</title>
Нужно дать пользователю вообще не подключать шаблоны
Пропишем - 
    public function indexAction() {
            $this->layout = false;
    //       $this->layout = 'main';
    //       $this->view = 'test';
        } 
Чтобы получить данные без оформления. без шаблона и вида. И, чтобы это заработало, добавим 
условие во view
    if ($layout === false) {
            $this->layout = false;
        } else {
            $this->layout = $layout ?: LAYOUT;
        }
И когда рендерим, добавим тоже условие во view 
    if(false !== $this->layout){
            $file_layout = APP . "/views/layouts/{$this->layout}.php";
            if(is_file($file_layout)) {
                require $file_layout;
            } else {
                echo "<p>Не найден шаблон <b>$file_layout</b></p>";
            }
        }
В main index.php и test.php напишем - <code><? = __FILE__?></code>