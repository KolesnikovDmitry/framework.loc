Фремворк MVC
Урок 1
Структура
1. app - структура приложения, с которой будет работать пользователь, в ней создадим 3 подпапки
    controllers
    models
    views
2. public - точка входа(frontcontroller), здесь же будут находится картинки, стили, шрифты, скрипты и т.д.
    css 
    images
    js
3.vendor - ядро фреймворка и библиотеки
    core
    libs
Все запросы должны перенаправляться на папку public 
Создадим в папке public index.php - это и будет наша точка входа
Напишем "echo __FILE__;" - посмотреть путь который у нас. 
Запросы должны быть перенаправлены на index.php. Для этого мы создадим два файла .htaccess

Первый файл мы создаем в корне , запишем в него
    AddDefaultCharset utf-8
    RewriteEngine On - модуль перенаправления
    RewriteRule ^(.*)$  /public/$1 -правило перенаправления, которое все запросы отправит в папку public.
    И все, что мы запомнили находится в переменной $1, перенаправляется в папку public
Второй файл .htaccess мы создаем в папке public , запишем в него два условия:
    RewriteCond %{REQUEST_FILENAME} !-f   условие перенаправления.
    Если это не файл, и это не папка, тогда мы выполним следующее условие переадресации
    RewriteRule (.*) index.php?$1 [L,QSA] - запомним все, что будет находится в строке запроса и отправим на index.php
    и Get- параметром добавим $1, также добавим флаг L, QSA(позволяет добавлять параметры к уже имеющеся в строке запроса url)

Создаем класс Router . Создадим временно публичный метод конструктора, чтобы убедиться, что он работает. Напишем в 
него echo "hello world"
В index.php обратимся к массиву $query = $_SERVER['QUERY_STRING'];
Нам нужно подключить класс Router - require_once "../vendor/core/Router.php";

Создадим обьект класса $router = new Router;
Создадим в классе Router два свойства: Все свойства и методы данного класса будут статичными.

    /*
        Массив, содержащий все маршруты
        @var $array
    */
    protected static $routes = [];
    
    /*
        Текущий маршрут
        $var $array
    */
    protected static $route = [];

    /*

Создадим в классе Router статичный метод add, который будет принимать два параметра, 
один будет принимать регулярное выражение $regexp ,второй - $route

public static function add($regexp, $route = []) {
        self::$routes[$regexp] = $route;
    }
В качестве ключа таблицы маршрутов, пойдет регулярное выражение, а значение текущий маршрут

Создадим два метода для тестирования, чтобы посмотреть ,что там находится

    public static function getRoutes() {
            return self::$routes;
        }

        public static function getRoute() {
            return self::route;
        }
    }
Уберем создание объекта router в index.php и создадим первое правило
Router::add('posts/add', ['controller'=>'posts', 'action'=>'add']);

Создадим функцию function.php для дебага в папке vendor, подпапки libs и родключим его в index.php

    function debug($arr) {
        echo '<pre>' . print_r($arr, true) . '</pre>';
    }

Для примера добавим еще несколько вариантов, например:
Router::add('posts/', ['controller' => 'Posts', 'action'=>'index']);
Router::add('', ['controller' => 'Main', 'action'=>'index']);

Для сравнение строки url с ключом в маршруте создадим статичный метод, в качестве параметра будет приниматься запрос 
url(переменная query). Перебираем в цикле наши свойства routes(таблицу маршрутов) и получаем 
из нее отдельно регулярное выражение($pattern) и отдельно маршрут, который соответствует этому регулярному выражению
Делаем простую проверку сравнения: Проверяем , если у нас переменная $url == $pattern, заполняем наше свойство $route.
И вернем работу нашей функции, возращая true. Если совпадение найдено не было,запрошен не 
существующий адрес, вернем false
   public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if ($url == $pattern) {
                self::$route = $route;
                return true;
            } 
        }
        return false;
    }
Сделаем проверку на совпадение маршрутов
    if(Router::matchRoute($query)){
        debug(Router::getRoute());
    } else {
        echo '404';
    }
Решим проблему концевого слэша и допишем функцию rtrim, не забыв при этом убрать в маршруте posts/, слеш
$query = rtrim($_SERVER['QUERY_STRING'], '/');


Урок 2
Класс Router 
Сделаем правило в index.php, которое провалидирует пустую строку
    Router::add('^$',['controller' => 'Main', 'action'=>'index']); -где в регулярном выражении написаны символы начала 
    и конца строки, что означает пустую строку.
Второе правило должно валидировать все остальные url-адреса, где первый сегмент это контроллер, а второй экшен
    Router::add('([a-z-]+)/([a-z-]+)'); - где в регулярном выражении разрешаем
    вводим латиницу , знак тире и один или больше символов, и также для экшена
    Нужно эти правила запомнить, потому что мы их мы собираемся хранить в route
Закомментирум пока эти правила:
//Router::add('posts/add', ['controller' => 'Posts', 'action'=>'add']);
//Router::add('posts', ['controller' => 'Posts', 'action'=>'index']);
//Router::add('', ['controller' => 'Main', 'action'=>'index']);

Пропишем в Router:
Используем в сравнении функцию preg_match. Первым параметром идет паттерн. Вторым url-адрес. 
Третьий для запоминания $matches. Проверим, что же у нас попадает в $matches - debug($matches);

Сделаем именованные ключи в регулярном выражении, и сделаем необязательный слеш и action 
И если action у нас нет, тогда мы сделаем в качестве такового index 
   Router::add('^(?P<controller>[a-z-]+)/?(?P<action>[a-z-]+)?$');

Опишем в Router метод dispatch, на вход принимает url. И здесь этот метод вызывает matchRoute
Если метод matchRoute возвращает true, зачит адрес найден. В противном случае используем 
http_response_code(404), и подключим страницу 404.html
    public static function dispatch($url) {
           if (self::matchRoute($url)) {
               echo 'ok';
           } else {
               http_response_code(404);
               include '404.html';
           }
       }
Создадим в папке public 404.html
    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <title>404 Not found</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <h1 style="text-align: center;">404 Страница не найдена....</h1>
    </body>
    </html>
В index.php вызовем метод dispatch - Router::dispatch($query);
В пустой массив root метода matchRoute необходимо положить контроллер и action. 
Мы пройдемся по нашему массиву matches и возьмем значения только тех ключей, которые являются строковыми.
Если у нас в ключ попадается строковое значение, тогда нам такая строка подходит.
    public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if (preg_match("#$pattern#i", $url, $matches)) {
                debug($matches);
                foreach($matches as $key => $value) {
                    if (is_string($key)) {
                        $route[$key] = $value;
                    }
                }
                self::$route = $route;
                debug($route);
                return true;
            } 
        }
        return false;
    }
Однако, если в адресной строке опустить action, то его нет в выводе. И если action нет, то по умолчанию
он должен быть index
      public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if (preg_match("#$pattern#i", $url, $matches)) {
                foreach($matches as $key => $value) {
                    if (is_string($key)) {
                        $route[$key] = $value;
                    }
                }
                if (!isset($route['action'])) {
                    $route['action'] = 'index';
                }
                self::$route = $route;
                debug(self::$route);
                return true;
            } 
        }
        return false;
    }

Теперь переходим к методу dispach. У нас в этом методе доступен self::route. И отсюда возьмем контроллер
    $controller = self::$route['controller'];
Далее проверяем,если у нас есть такой класс в $controller, тогда мы его должны подключить.
В противном случае выведем сообщение, что контроллер не найден.
      public static function dispatch($url) {
        if (self::matchRoute($url)) {
            $controller = self::$route['controller'];
            if(class_exists($controller)){
                echo 'ok';
            } else {
                echo "Контроллер <b>$controller</b> не найден";
            }
        } else {
            http_response_code(404);
            include '404.html';
        } 
    }
Соответственно, создадим свой первый контроллер в папке app/controllers - Posts.php 
И еще Main.php. И временно подключим их в index.php
    require_once '../app/controllers/Posts.php';
    require_once '../app/controllers/Main.php';
Создадим еще класс PostsNew . И он должен быть найден при обращении в адресной строке posts-new
Сделаем в Router метод upperCamelCase. На вход будет пинимать имя класса $name
Распечатаем его:
    protected static function upperCamelCase($name) {
        debug($name);
    }
   И вставим вывод в метод dispatch - self::upperCamelCase($controller);
Уберем тире с имени контроллера - $name = str_replace('-', ' ',$name);
Сделаем заглавными первые буквы двух слов  - $name = ucwords($name);
Заменим пробел, чтобы соединить два слова - $name = str_replace(' ', '', $name);
Теперь сократим код в одну строку  - $name = str_replace(' ', '', ucwords(str_replace('-', ' ',$name)));

И вернем результат:
protected static function upperCamelCase($name) {
    return $name = str_replace(' ', '', ucwords(str_replace('-', ' ',$name)));
}

В Routere в методе dispatch исправим 
    $controller = self::$route['controller'] на 
    $controller = self::upperCamelCase(self::$route['controller']);
Создадим в папке app/controllers контроллер PostsNew
В методе dispatch создадим обьект данного класса - $cObj = new $controller;
Чтобы убедиться, что все работает создадим временно в PostsNew конструктор
    class PostsNew {

        public function __construct() {
            echo __METHOD__;
            } 
        }
    }
Обьект контроллера, мы успешно создали,теперь необходимо вызвать метод данного контроллера. 
Поступим, так же, как и с контроллером. В переменную action получим из self::route, необходимое нам 
значение. И проверим, если у нас существует, такой метод $action у класса $cObj, то выведем его 
$cObj->$action(); 
Иначе напишем в Routre метода dispach: 
    if(method_exists($cObj, $action )) {
        $cObj->$action();
    } else {
        echo "Метод <b>$controller::$action</b> не найден";
    }
Давайте в PostsNew создадим еще пару методов
     public function test()
    {
      echo __METHOD__;
    }
    
    public function testPage()
    {
      echo __METHOD__;
    }
Чтобы, вызвать testPage, надо нам убрать дефис и за ним следующую букву сделать заглавной.
Создадим еще один метод lowerCamelCase. Первую букву будет делать маленькой все остальные с большой.
    protected static function lowerCamelCase($name) {
        return lcfirst(self::upperCamelCase($name));
    }
В dispatch пропишем - $action = self::lowerCamelCase(self::$route['action']);
В PostsNew создадим еще метод: before, но нужно сделать, чтобы пользователь не мог его вызвать.
К каждому методу, который пользователь сможет вызывать, добавим постфикс Action 
А в Routere метода dispatch сконкатеннируем . "Action";
$action = self::lowerCamelCase(self::$route['action']) . "Action";

Сделаем константы:
define('WWW', __DIR__ ); - будет указывать на текущую папку public C:\OSPanel\domains\framework.loc\public
define('CORE', dirname(__DIR__). 'vendor/core'); - ядро сайта. С помощью функции dirname, поднимемся в папку выше.
Все константы будут заканчиваться без концевого слеша. C:\OSPanel\domains\framework.locvendor/core
define('ROOTE', dirname(__DIR__)); - корень сайта. C:\OSPanel\domains\framework.loc
define('APP', dirname(__DIR__) . '/app'); - C:\OSPanel\domains\framework.loc/app


Далее, сделаем функцию автозагрузки
spl_autoload_register(function($class){
    $file = APP . "/controllers/$class.php";
});
И проверим, если у нас есть такой файл, то мы его подключаем

В index.php пропишем еще маршрут 
Router::add('^pages/(?P<action>[a-z-]+)?$',['controller' => 'Posts']);




Урок 3. Автозагрузка. Контроллер фреймворка. Пространство имен.
Закомментируем класс Router. И посмотрим, что же у нас ищется в автозагрузчике
spl_autoload_register(function($class){
    debug($class);
    $file = APP . "/controllers/$class.php";
    if(is_file($file)){
        require_once $file;
    }
});
В Routere запишем - namespace vendor\core;
В index.php пропишем use vendor\core\Router;
Нам остается только в функции автозагрузки заменить обратные слеши на прямые и доканкатенировать
.php(т.е. дописать расширение) 
    spl_autoload_register(function($class){
        $file = ROOTE . '/' . str_replace('\\', '/', $class) . ".php";
        if(is_file($file)){
            require_once $file;
        }
    });
 
Включим контроль ошибок в index.php 
error_reporting(-1);

Допишем пространство имен в метод dispatche - $controller = 'app\controllers\\' . self::upperCamelCase(self::$route['controller']);
И пропишем пространство имен в контроллерах

namespace app\controllers;

Нам надо подключить шаблон(повторяющуся часть каждой страницы(head, body, стили, скриптов)) 
и вид(некая изменяющаяся часть каждого сайта(контент
Под каждый вид в папке views создадим папку по имени контроллера
Создадим папку Posts и PostsNew в views. Виды будут называться по имени action. То есть в 
папке views/Posts создадим два файла index.php и test.php
В index.php напишем <h1>INDEX</h1>
В test.php напишем <h1>TEST</h1>

Немного исправим методы dispatch и matchRoute, потому как контроллер выходит с маленькой буквы.
     public static function matchRoute($url) {
        foreach (self::$routes as $pattern => $route) {
            if (preg_match("#$pattern#i", $url, $matches)) {
                foreach($matches as $key => $value) {
                    if (is_string($key)) {
                        $route[$key] = $value;
                    }
                }
                if (!isset($route['action'])) {
                    $route['action'] = 'index';
                }
                $route['controller'] = self::upperCamelCase($route['controller']); 
                self::$route = $route;
                return true;
            } 
        }
        return false;
    }


    public static function dispatch($url) {
        if (self::matchRoute($url)) {
            $controller = 'app\controllers\\' . self::$route['controller'];
            debug(self::$route);
            if(class_exists($controller)){
                $cObj = new $controller;
                $action = self::lowerCamelCase(self::$route['action']) . "Action";
                if(method_exists($cObj, $action )) {
                    $cObj->$action();
                } else {
                    echo "Метод <b>$controller::$action</b> не найден";
                }
            } else {
                echo "Контроллер <b>$controller</b> не найден";
            }
        } else {
            http_response_code(404);
            include '404.html';
        } 
    }
У нас теперь в маршруте, содержится вся информация, для подключения нужного вида. И теперь нужно
передать информацию в наш контроллер. Нужно в обьект класса $cObj передать self::$route
$cObj = new $controller(self::$route);
Соответственно, нам понадобится некое свойство $route = [];
Создадим, также публичный метод __construct, и будет выводить то, что приходит в наш конструктор параметром
при создании обьекта.
    public function __construct($route) {
            $this->route = $route;
    }
И теперь, у нас в debug($this->$route) содержится вся необходимая информация
И поэтому нам необходим некий базовый класс контроллера, который будет находиться в ядре core
Создадим папку в core / base и ней создадим абстрактный класс Controller и весь конструктор  с Pouter.php
перенесем в класс Controller
    public $route = [];
    
    public function __construct($route) {
        $this->route = $route;
    }
И нам остается только наследоваться от базового класса Controller
    namespace app\controllers;
    use vendor\core\base\Controller;

    class Posts extends Controller{

        public function indexAction() {
            echo __METHOD__;
        }

        public function testAction() {
            debug($this->route);
            echo __METHOD__;
        }
    }
Сделаем у классов контроллера тоже самое. Сделаем временно подключение вида
    abstract class Controller {
        public $route = [];
        public $view;

        public function __construct($route) {
            $this->route = $route;
            $this->view = $route['action'];
            include APP . "/views/{$route['controller']}/{$this->view}.php";
        }
    }
Напишем в Page:
    namespace app\controllers;
    use vendor\core\base\Controller;

    class Page extends Controller{

        public function viewAction() {
            debug($this->route);
            echo __METHOD__;
        }
    }
Сейчас у нас фактически один action отвечает за одну страницу. Это не всегда удобно
Добавим и изменим правила 
Router::add('^page/(?P<action>[a-z-]+)/(?P<alias>[a-z-]+)$',['controller' => 'Page']);
Уберем средний сегмент view. Напишем еще правило, в котором action уже убираем и оставляем только
alias, но action при этом должен быть именно view
Router::add('^page/(?P<alias>[a-z-]+)$',['controller' => 'Page', 'action' => 'view']);
Далее нам нужно разделить явные get-параметры от неявных и отрезать их.
Введем в адресную строку - http://framework.loc/page/view/about?page=1&val=2&val=3
И в index.php после подключения функций напишем debug($_GET);, где получим вывод
Array
(
    [page/view/about] => неявные get- параметры
    [page] => 1 - явные get-параметры
    [val] => 3
)
Создадим в Router метод removeQueryString, который будет обрезать возможные get-параметры
На вход он принимает url- адрес. Распечатаем его 
  protected static function removeQueryString($url) {
        debug($url);
        return $url;
    }
В методе dispatch распечатаем его - $url = self::removeQueryString($url);
Найдем строку по разделителю:
  protected static function removeQueryString($url) {
        if($url) {
            $params = explode('&', $url, 2);
            if(false === strpos($params[0], ))
        }
        //debug($url);
        return $url;
    }

Во всем случаях по-возможности мы должны взять только неявные get-параметры
 protected static function removeQueryString($url) {
        if($url) {
            $params = explode('&', $url, 2);
            if (false === strpos($params[0], '=')) {
                return rtrim($params[0], '/');
            } else {
                return '';  
            }
        }
    }

Выведем в методе dispatch - var_dump($url); Для версии php 8 и выше нужно в matchRoute привести к строковой
функции strval($url), чтобы пустая строка не приводилась к null 




Урок 4. Виды и шаблоны
Создадим базовый класс вида vendor/core/base/view.php
Нам понадобится три свойства - route(чтобы взять из него контроллер и значение action)
    class View {

        /**
         * текущий маршрут и параметры(controller, action, params)
         * @var array
         */
        public $route = [];

        /**
         * текущий вид
         * @var string
         */
        public $view;

        /**
         * текущий шаблон 
         * @var string
         */
        public $layout;
    }
Понадобится метод конструктора. Когда мы будет создавать обьект класса view, то будем заполнять все эти свойства,
текущими значениями вида и шаблона.
Заведем в index.php константу для нашего шаблона - define('LAYOUT', 'default');//default template
    public function __construct($route, $layout = '', $view = '' ) {
            $this->route = $route;
            $this->layout = $layout ?: LAYOUT; - если у нас layout был передан, то используем его, иначе используем константу LAYOUT 
            $this->view = $view;
        }

И понадобится метод render - мы его будем вызывать автоматом и в нем будем подключать вид,
шаблон и определять переменные вида и шаблона, которые,пользователь передает из action контроллера
    public function render() {
        $file_view = APP . "/views/{$this->route['controller']}/{$this->view}.php";
        if (is_file($file_view)) {
            require_once $file_view;
        } else {
            echo "<p>Не найден вид<b>$file_view</b></p>";
        }
    }
Нам необходимо в контроллере создать обьект вида и вызвать его метод render. Допишем 
    public function __construct($route) {
        $this->route = $route;
        $this->view = $route['action'];
    }
    
     public function getView() {
        $vObj = new View($this->route, $this->layout, $this->view);
        $vObj->render();
    }
Подключим в dispatch -  $cObj->getView();

Создадим некий общий класс в app/controllers - App.php отнаследуемся от базового контроллера
Controller
    namespace app\controllers;

    use vendor\core\base\Controller;
    class App extends Controller{
        //put your code here
    }
Теперь каждый класс будем наследовать от класса App

Нам надо чтобы вид не подключался раньше шаблона, и тем более чтобы он не выводился, до тех пор пока мы этого не захотим.
Подключим возможности буферизации, которая фактически, все что идет после нее буферизирует, т.е.
складывает в буфер обмена, не выводя при этом на экран.
Заведем переменную и положим туда все, что находится в буфере обмена - $content = ob_get_clean();
которая очищает буфер обмена и складывает в $content
Теперь мы можем подключать наш шаблон, а внутри шаблона использовать переменную $content с видом 
в нужном месте нашего шаблона.
Шаблон подключаем, либо тот, который укажет пользователь на уровне контроллера и экшена или
если он не указал, тогда мы используем дефолтный шаблон, который лежит у нас в константе LAYOUT
И проверим, если у нас существует такой файл layuout, тогда мы его подключаем
Выводится сообщение не найден шаблон, давайте его найдем.
В папке views создадим папку layouts и в ней default.php
В шаблон подключим bootstrap, скачаем его с офф.сайта. Переименуем в bootstrap. И закинем в папку 
public
В default.php вставим шаблон bootstrap
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>DEFAULT</title>

        <link href="/public/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
          <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->
      </head>
      <body>
        <h1>Hello, world!</h1>
        <?= $content?> - подключим переменную

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <script src="/public/bootstrap/js/bootstrap.min.js"></script>
      </body>
    </html>

Все теперь подключается по умолчанию, шаблон и вид.
Сделаем проверку во view - 
 public function __construct($route, $layout = '', $view = '' ) {
        $this->route = $route;
        $this->layout = $layout ?: LAYOUT;
        $this->view = $view;
        var_dump($this->layout); 
        var_dump($this->view); 
    }
Посмотрим, что там находится. Попробуем передать другой шаблон. Для этого идем в main 
    class Main extends App{
        public function indexAction() {
            $this->layout = 'main';
            $this->view = 'test';
         }
}
Шаблон main мы успешно переопределили. Это мы сделали на уровне action. Теперь сделаем
на уровне всего класса.
    class Main extends App{
        public $layout = 'main';
        public function indexAction() {
    //       $this->layout = 'main';
    //       $this->view = 'test';
        }
    }
Чтобы, убедиться, что все работает. создадим вид test.php во views/Main
В views/layouts создадим шаблон main.php
С default возьмем всю разметку вставим ее в main
title перепишем в main -  <title>MAIN</title>
Нужно дать пользователю вообще не подключать шаблоны
Пропишем - 
    public function indexAction() {
            $this->layout = false;
    //       $this->layout = 'main';
    //       $this->view = 'test';
        } 
Чтобы получить данные без оформления. без шаблона и вида. И, чтобы это заработало, добавим 
условие во view
    if ($layout === false) {
            $this->layout = false;
        } else {
            $this->layout = $layout ?: LAYOUT;
        }
И когда рендерим, добавим тоже условие во view 
    if(false !== $this->layout){
            $file_layout = APP . "/views/layouts/{$this->layout}.php";
            if(is_file($file_layout)) {
                require $file_layout;
            } else {
                echo "<p>Не найден шаблон <b>$file_layout</b></p>";
            }
        }
В main index.php и test.php напишем - <code><? = __FILE__?></code>
Напишем специальный метод в контроллере set, который будет принимать некие параметры
Определим свойство -
    /**
     * пользовательские данные
     * @var array
     */
    public $vars = [];
Остается только передать наши пользовательские данные в вид. Для этого передаем в render в 
контроллере
     public function getView() {
        $vObj = new View($this->route, $this->layout, $this->view);
        $vObj->render($this->vars);
                
    }
И в методе render view этот метод мы должны принять. И сразу их продебажим
 public function render(array $vars) {
        debug($vars);
Передадим данные в виде массива в $this->set(['name' => $name, 'hi'=> 'Hello']); 
Эти данные доступны только в методе render. Нам надо сделать доступными для вида и шаблона,
использовав функцию exctract(которая распарсивает массив и создает одноименные переменные)
Перепишем в main -
    $name = "Ande";
        $hi = "hello";
        $colors = [
          $white = "Белый",
          $black = "Черный",
        ];
        $this->set(compact('name', 'hi', 'colors'));



Урок 5. Модели и работа с БД.
Переименуем контроллеры в AppController, MainController, PageController, PostsController,
PostsNewController и  изменим в них код например:
    class MainController extends AppController
И в Routere добавим постфикс Controller
    $controller = 'app\controllers\\' . self::$route['controller'] . "Controller";
Создадим БД в phpmyadmin - framework. Также нам потребуется хранить где-то настройки подключения к БД
Будем использовать PDO. Созадим в корне папку config и в ней config_db.php(это будет обычный массив,который мы
и будем возвращать)
    Сделаем подключение:
        return [
            'dsn' => 'mysql:host=localhost;dbname=framework;charset=utf-8',
            'user' => 'root',
            'pass' => '',
        ];
Создадим в core класс Db
И в папке base создадим класс Model. И создадим файл в приложении, первую модель, которая будет
совпадать с именем контроллера - Main.php
В классе DB обычно подключают Singletone. Создается защищенное свойство (protected/private)
и создается защищенный конструктор, с тем чтобы невозможно было создать обьект данного класса.
Далее создается публичный статический метод, который будет проверять создан ли обьект данного класса,
или нет. Если создан вернет, если не создан, создаст и затем вернет.
    class DB {
    
        protected $pdo;
        protected static $instance;

        protected function __construct() {
            $db = require ROOT . '/config/config_db.php';
            $this->pdo = new \PDO($db['dsn'],$db['user'],$db['pass']);
        }

        public static function instance() {
            if (self::$instance === null) {
                self::$instance = new self;
            }
        }
        return self::$inststance;
    }
Далее на потребуются два низкоуровневых метода, которые в дальнейшем будут использоваться 
нашей моделью для выполнения запросов.
     public function execute($sql) {
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute();
    }
Метод execute будет нужен, когда нам будет нужно выполнить просто sql- запрос и данные из базы данных
нам не нужны. Например, создать или изменить таблицу в БД. Нам важен ответ, либо truе, либо
false. 
Следующий метод query - это тоже будет sql - запрос. Он тоже будет его готовить, выполнять,
но еще и возвращать данные. Этот метод необходим для запросов, типа select, которые осуществляют
выборку данных из базы.
    public function query($sql) {
        $stmt = $this->pdo->prepare($sql);
        $res = $stmt->execute();
    }
И проверим , что у нас находится в переменной $res. Если там не false, значит там есть 
какие-то данные. Если false, значит там ошибка, или некорректный запрос пустой, чтобы не вернулось
false просто вернем пустой массив.
     public function query($sql) {
        $stmt = $this->pdo->prepare($sql);
        $res = $stmt->execute();
        if($res !== false) {
            return $stmt->fetchAll();
        }
        return [];
    }
}

Для модели нам понадобится то же свойство, в котором мы будем хранить подключение к БД
    use vendor\core\Db;
    abstract class Model {

        protected $pdo;
        protected $table;

        public function __construct() {
            $this->pdo = Db::instance();
        }
    }
Напишем пару методов в Model.php 
Первый метод query, который по-сути будет оберткой над execute класса Db;
Данный метод нужен, чтобы выполнить sql-запрос и выполнить, либо true, либо false.
    public function query($sql) {
        return $this->pdo->execute();
    }
И второй метод, который возвращает все данные из таблицы. В данном случае из той таблицы, с 
которой работает модель.
    public function findAll() {
        $sql = "SELECT * FROM {$this->table}";
        return $this->pdo->query($sql);
    }
Будем наследовать класс модели в Main.php. Необходимо определить свойство таблицы
public $table = 'posts'; На главной странице будет выводиться таблица posts
И протестируем её. Нам небходимо создать обьект модели Main, для того чтобы нам 
были доступны все его методы(query и findAll)
Запишем и  проверим в Main 
     public function indexAction() {
        $model = new Main;
        $res = $model->query("CREATE TABLE Staff (
                                id INT,
                                name VARCHAR(255) NOT NULL,
                                position VARCHAR(30),
                                birthday Date); ");
        var_dump($res);
        $title = "PAGE_TITLE";
        $this->set(compact('title'));
    }
Теперь протестируем метод findAll, который просто выбирает все данные из таблицы
В MainController напишем:
     $posts = $model->findAll();
        debug($posts);
Выводится массив. Но нам нужно, чтобы выводился только ассоциативный массив
Когда работают с методом fetchAll в классе Db, подают один и тот же параметр
 return $stmt->fetchAll(\PDO::FETCH_ASSOC); И получаем только ассоциативный массив
Подадим этот параметр один раз и в момент соединения с БД
Сформируем переменную для показа ошибок в Db
    $options = [
            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
            \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
        ];
Теперь эти данные мы можем передавать в вид и в виде уже их выводить
В папке Main index.php выведем посты, используя bootstrap 
    <div class="container">
    <?php if (!empty($posts)):?>
        <?php foreach ($posts as $post):?>
            <div class="panel panel-default">
                <div class="panel-heading">
                  <h3 class="panel-title"> <?= $post['title']?></h3>
                </div>
                <div class="panel-body">
                  <?= $post['text']?>
                </div>
            </div>
        <?php endforeach;?>
    <?php endif;?>
</div>
Нам необходимо создать модель, в ней необходимо создать свойство table, значением которой
 будет таблица, с которой будет работать наша модель.  
Далее в контроллере необходимо создать обьект нужной нам модели, ну и вызвать метод findAll();
Данные получаются , они передаются в вид. А в виде мы можем уже по ним пройтись циклом, и в 
нужном нам формате вывести данные.
Давайте посчитаем количество запросов и будем сохранять эти запросы.
У нас будет два публичных свойства:
public static $countSql = 0;
 public static $queries = []; - пустой массив, в который мы будем сохранять запросы.
И, чтобы это сделать, у нас есть два метода execute и query
    public function execute($sql) {
        self::$countSql++;
        self::$queries[] = $sql;
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute();
    }

    public function query($sql) {
           self::$countSql++;
           self::$queries[] = $sql;
           $stmt = $this->pdo->prepare($sql);
           $res = $stmt->execute();
           if($res !== false){
               return $stmt->fetchAll();
           }
           return [];
       }
Теперь мы можем их вывести, например в шаблоне default
    <?= debug(vendor\core\Db::$countSql)?>
    <?= debug(vendor\core\Db::$queries)?>

Напишем метод findOne(), который будет получать одну запись, в параметры добавим id и field
Добавим также свойство protected $primary_key = 'id';
Параметр field будет указывать по какому полю мы будем выбирать данные и данное поле будет необязательным
И проверяем, если у нас поле field передано, то мы будем брать его, если не передано будем брать
свойство $primary_key, либо то что мы с вами определим в нашей модели
Формируем sql запрос $sql = "SELECT * FROM {$this->table} WHERE $field = ? LIMIT 1";
Выбираем из таблицы текущей модели, где наше поле field равняется id 
$sql = "SELECT * FROM {$this->table} WHERE $field = ? LIMIT 1";
     public function findOne($id, $field = '') {
       $field = $field ?: $this->primary_key;
       $sql = "SELECT * FROM {$this->table} WHERE $field = ? LIMIT 1";
       return $this->pdo->query($sql, [$id]);
    }
Но например мы хотим выбирать записи не по полю id, а по полю category_id
В этом случае мы просто переопредим свойство primary_key
public $primary_key = 'category_id';
Также мы можем в параметре field указать любое другое поле
$posts = $model->findOne('Редко используемые селекторы JQuery', 'title');
Напишем следующий метод findBySql, который позволяет выбрать что-либо из базы данных по произвольному
sql - запросу
    public function findBySql($sql, $params = []) {
        return $this->pdo->query($sql, $params);
    }
И проверим 
    $data = $model->findBySql("SELECT * FROM posts ORDER BY id DESC LIMIT 2");
    debug($data);
Или 
    $data = $model->findBySql("SELECT * FROM {$model->table} WHERE title LIKE ?", ['%то%']);
И третьий метод findLike с параметрами str, field, table=''
Если у нас передана таблица, значит мы возьмем ее, в противном случае мы возьмем таблицу модели
    public function findLike($str, $field, $table = "") {
        $table = $table ?: $this->table;
        $sql = "SELECT * FROM $table WHERE $field LIKE ?";
        return $this->pdo->query($sql, ['%' . $str . '%']);
    }
И проверим -  $data = $model->findLike('то', 'title');


Урок 8. Подключение ORM RedBeanPhp
В классе DB закомментируем подключение к БД
    $options = [
            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
            \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
        ];
        $this->pdo = new \PDO($db['dsn'], $db['user'], $db['pass'],$options);

 И вызовы sgl 
       public function execute($sql, $params = []) {
//        self::$countSql++;
//        self::$queries[] = $sql;
//        $stmt = $this->pdo->prepare($sql);
//        return $stmt->execute($params);
//    }
//    
//    public function query($sql, $params = []) {
//        self::$countSql++;
//        self::$queries[] = $sql;
//        $stmt = $this->pdo->prepare($sql);
//        $res = $stmt->execute($params);
//        if($res !== false){
//            return $stmt->fetchAll();
//        }
//        return [];
//    }
  Теперь подключим redbeanphp и вставим в конструктор Db.php
  protected function __construct() {
        $db = require ROOT . '/config/config_db.php';
        require 'rb.php';
        R::setup( $db['dsn'], $db['user'], $db['pass']);
        //R::freeze(true);
        R::fancyDebug(TRUE);
    }
    
Файлик rb.php скопируем и добавим в папку libs
И сделаем константу LIBS 
define('LIBS', ROOT . '/vendor/libs');
В MainController.php выведем страницу постов и страницу категорий
$posts = \R::findAll('posts'); 
$menu = \R::findAll('category'); 
$this->set(compact('title', 'posts', 'menu'));
Идем в вид views/main/index. Проверим, что у нас выводится список категорий,
<?php debug($menu);?>
И выведем красиво через bootstrap
    <ul class="nav nav-pills">
    <?php foreach ($menu as $item): ?>
        <li><a href="category/<?=$item['id']?>"><?= $item['title']?></a></li>
    <?php endforeach; ?>
    </ul>
Вынесем меню в AppController.
Вставим в default.php 
        <div class="container">
          <ul class="nav nav-pills">
            <?php foreach ($menu as $item): ?>
                <li><a href="category/<?=$item['id']?>"><?= $item['title']?></a></li>
            <?php endforeach; ?>
          </ul>
            <?= $content?>
            <?php //debug(vendor\core\Db::$countSql)?>
            <?php //debug(vendor\core\Db::$queries)?>
       </div>
    Заведем в AppController.php конструктор , который будет наследоваться от родительского
Controllera. Добавим обьект модели, без нее не будет работать. И выведем из базы меню
кетегорий
    public $menu;
    
    public function __construct($route) {
        parent::__construct($route);
        new \app\models\Main;
        $this->menu = \R::findAll('category'); 
    }

В MainController напишем: $menu = $this->menu;

Помимо общего контроллера, используется еще вариант компонентов или виджетов. Создается компонент
(виджет)- это законченный модуль, в котором уже например получается меню.

Урок 9. Ответы на вопросы
В странице default напишем код, который позволит не выводить на какой-то странице
список меню
    <?php if (!empty($menu)): ?>
          <ul class="nav nav-pills">
            <?php foreach ($menu as $item): ?>
                <li><a href="category/<?=$item['id']?>"><?= $item['title']?></a></li>
            <?php endforeach; ?>
          </ul>
     <?php endif; ?>
В AppControllere создадим метод, который будет заполнять метаданные
Создадим публичное свойство public $meta = [];
     protected function setMeta($title = '', $desc = '', $keywords = '') {
        $this->meta['title'] = $title;
        $this->meta['desc'] = $desc;
        $this->meta['keywords'] = $keywords;
    }
В MainControllere напишем :
    $this->setMeta('Главная', 'описание страницы', 'ключевые слова');
    $meta = $this->meta;
В defautl выведем их
    <title><?= $meta['title'] ?></title>
    <meta name="description" content="<?= $meta['desc'] ?>">
    <meta name="keywords" content="<?= $meta['keywords'] ?>">


Урок 10. Шаблон реестр.
Работа с компонентами. 
создадим класс php в vendor/libs - Cache.php. И для примера создадим класс Test.php
там же. Создадим в папке config php-файл config.php
 в нем создадим пустой массив $config = []; и в нем будут содержаться какие-либо настройки,
компоненты 
    $config = [
    'components' => [
      'cache' => 'vendor\libs\Cache',
      'test' => 'vendor\libs\Test',
    ]
  ];
  
  return $config;
Для теста создадим в папке public, папку test. Там создадим файл index.php, но внего напишем класс
Registry. И создадим еще одну папку, в папке test- classes в тестовых целях. В ней создадим
класс php Cache. В пространстве имен запишем classes. И создадим класс Test
    namespace classes;


    class Test {
        public function go() {
            echo "Поехали!";
        }
    }
Класс Registry
    
        class Registry {

            public static $objects = []; контейнер для обьектов 

            protected static $instance;

            protected function __construct() {
                $config  = require ROOT . '/config/config.php';
                foreach ($config['components'] as $name => $component) {
                    self::$objects[$name] = new $component;
                }
            } 

            public static function instance() {
              if (self::$instance === null) {
                  self::$instance = new self;
              }
              return self::$instance;
          }

          public function __get($name) {
              if (is_object(self::$objects[$name])) {
                  return self::$objects[$name];
              }
          }

          public function __set($name, $object) {
              if (!isset(self::$objects[$name])) {
                  self::$objects[$name] = new $object;
              }
          }

          public function getList() {
               echo '<pre>';
               var_dump(self::$objects);
               echo '</pre>';
          }
        }
